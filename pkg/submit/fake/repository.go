// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"github.com/sykesm/batik/pkg/transaction"
)

type Repository struct {
	ConsumeStateStub        func(transaction.StateID) error
	consumeStateMutex       sync.RWMutex
	consumeStateArgsForCall []struct {
		arg1 transaction.StateID
	}
	consumeStateReturns struct {
		result1 error
	}
	consumeStateReturnsOnCall map[int]struct {
		result1 error
	}
	GetStateStub        func(transaction.StateID, bool) (*transaction.State, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
		arg1 transaction.StateID
		arg2 bool
	}
	getStateReturns struct {
		result1 *transaction.State
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 *transaction.State
		result2 error
	}
	GetTransactionStub        func(transaction.ID) (*transaction.Transaction, error)
	getTransactionMutex       sync.RWMutex
	getTransactionArgsForCall []struct {
		arg1 transaction.ID
	}
	getTransactionReturns struct {
		result1 *transaction.Transaction
		result2 error
	}
	getTransactionReturnsOnCall map[int]struct {
		result1 *transaction.Transaction
		result2 error
	}
	PutStateStub        func(*transaction.State) error
	putStateMutex       sync.RWMutex
	putStateArgsForCall []struct {
		arg1 *transaction.State
	}
	putStateReturns struct {
		result1 error
	}
	putStateReturnsOnCall map[int]struct {
		result1 error
	}
	PutTransactionStub        func(*transaction.Transaction) error
	putTransactionMutex       sync.RWMutex
	putTransactionArgsForCall []struct {
		arg1 *transaction.Transaction
	}
	putTransactionReturns struct {
		result1 error
	}
	putTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Repository) ConsumeState(arg1 transaction.StateID) error {
	fake.consumeStateMutex.Lock()
	ret, specificReturn := fake.consumeStateReturnsOnCall[len(fake.consumeStateArgsForCall)]
	fake.consumeStateArgsForCall = append(fake.consumeStateArgsForCall, struct {
		arg1 transaction.StateID
	}{arg1})
	stub := fake.ConsumeStateStub
	fakeReturns := fake.consumeStateReturns
	fake.recordInvocation("ConsumeState", []interface{}{arg1})
	fake.consumeStateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) ConsumeStateCallCount() int {
	fake.consumeStateMutex.RLock()
	defer fake.consumeStateMutex.RUnlock()
	return len(fake.consumeStateArgsForCall)
}

func (fake *Repository) ConsumeStateCalls(stub func(transaction.StateID) error) {
	fake.consumeStateMutex.Lock()
	defer fake.consumeStateMutex.Unlock()
	fake.ConsumeStateStub = stub
}

func (fake *Repository) ConsumeStateArgsForCall(i int) transaction.StateID {
	fake.consumeStateMutex.RLock()
	defer fake.consumeStateMutex.RUnlock()
	argsForCall := fake.consumeStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) ConsumeStateReturns(result1 error) {
	fake.consumeStateMutex.Lock()
	defer fake.consumeStateMutex.Unlock()
	fake.ConsumeStateStub = nil
	fake.consumeStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) ConsumeStateReturnsOnCall(i int, result1 error) {
	fake.consumeStateMutex.Lock()
	defer fake.consumeStateMutex.Unlock()
	fake.ConsumeStateStub = nil
	if fake.consumeStateReturnsOnCall == nil {
		fake.consumeStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consumeStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) GetState(arg1 transaction.StateID, arg2 bool) (*transaction.State, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
		arg1 transaction.StateID
		arg2 bool
	}{arg1, arg2})
	stub := fake.GetStateStub
	fakeReturns := fake.getStateReturns
	fake.recordInvocation("GetState", []interface{}{arg1, arg2})
	fake.getStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *Repository) GetStateCalls(stub func(transaction.StateID, bool) (*transaction.State, error)) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = stub
}

func (fake *Repository) GetStateArgsForCall(i int) (transaction.StateID, bool) {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	argsForCall := fake.getStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Repository) GetStateReturns(result1 *transaction.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 *transaction.State
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetStateReturnsOnCall(i int, result1 *transaction.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 *transaction.State
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 *transaction.State
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransaction(arg1 transaction.ID) (*transaction.Transaction, error) {
	fake.getTransactionMutex.Lock()
	ret, specificReturn := fake.getTransactionReturnsOnCall[len(fake.getTransactionArgsForCall)]
	fake.getTransactionArgsForCall = append(fake.getTransactionArgsForCall, struct {
		arg1 transaction.ID
	}{arg1})
	stub := fake.GetTransactionStub
	fakeReturns := fake.getTransactionReturns
	fake.recordInvocation("GetTransaction", []interface{}{arg1})
	fake.getTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetTransactionCallCount() int {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	return len(fake.getTransactionArgsForCall)
}

func (fake *Repository) GetTransactionCalls(stub func(transaction.ID) (*transaction.Transaction, error)) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = stub
}

func (fake *Repository) GetTransactionArgsForCall(i int) transaction.ID {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	argsForCall := fake.getTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) GetTransactionReturns(result1 *transaction.Transaction, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	fake.getTransactionReturns = struct {
		result1 *transaction.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransactionReturnsOnCall(i int, result1 *transaction.Transaction, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	if fake.getTransactionReturnsOnCall == nil {
		fake.getTransactionReturnsOnCall = make(map[int]struct {
			result1 *transaction.Transaction
			result2 error
		})
	}
	fake.getTransactionReturnsOnCall[i] = struct {
		result1 *transaction.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) PutState(arg1 *transaction.State) error {
	fake.putStateMutex.Lock()
	ret, specificReturn := fake.putStateReturnsOnCall[len(fake.putStateArgsForCall)]
	fake.putStateArgsForCall = append(fake.putStateArgsForCall, struct {
		arg1 *transaction.State
	}{arg1})
	stub := fake.PutStateStub
	fakeReturns := fake.putStateReturns
	fake.recordInvocation("PutState", []interface{}{arg1})
	fake.putStateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) PutStateCallCount() int {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	return len(fake.putStateArgsForCall)
}

func (fake *Repository) PutStateCalls(stub func(*transaction.State) error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = stub
}

func (fake *Repository) PutStateArgsForCall(i int) *transaction.State {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	argsForCall := fake.putStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutStateReturns(result1 error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = nil
	fake.putStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutStateReturnsOnCall(i int, result1 error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = nil
	if fake.putStateReturnsOnCall == nil {
		fake.putStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutTransaction(arg1 *transaction.Transaction) error {
	fake.putTransactionMutex.Lock()
	ret, specificReturn := fake.putTransactionReturnsOnCall[len(fake.putTransactionArgsForCall)]
	fake.putTransactionArgsForCall = append(fake.putTransactionArgsForCall, struct {
		arg1 *transaction.Transaction
	}{arg1})
	stub := fake.PutTransactionStub
	fakeReturns := fake.putTransactionReturns
	fake.recordInvocation("PutTransaction", []interface{}{arg1})
	fake.putTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) PutTransactionCallCount() int {
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	return len(fake.putTransactionArgsForCall)
}

func (fake *Repository) PutTransactionCalls(stub func(*transaction.Transaction) error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = stub
}

func (fake *Repository) PutTransactionArgsForCall(i int) *transaction.Transaction {
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	argsForCall := fake.putTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutTransactionReturns(result1 error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = nil
	fake.putTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutTransactionReturnsOnCall(i int, result1 error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = nil
	if fake.putTransactionReturnsOnCall == nil {
		fake.putTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.consumeStateMutex.RLock()
	defer fake.consumeStateMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Repository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
