// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/sykesm/batik/pkg/transaction"
)

type Repository struct {
	ConsumeStatesStub        func(...transaction.StateID) error
	consumeStatesMutex       sync.RWMutex
	consumeStatesArgsForCall []struct {
		arg1 []transaction.StateID
	}
	consumeStatesReturns struct {
		result1 error
	}
	consumeStatesReturnsOnCall map[int]struct {
		result1 error
	}
	GetStateStub        func(transaction.StateID) (*transaction.State, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
		arg1 transaction.StateID
	}
	getStateReturns struct {
		result1 *transaction.State
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 *transaction.State
		result2 error
	}
	GetTransactionStub        func(transaction.ID) (*transaction.Transaction, error)
	getTransactionMutex       sync.RWMutex
	getTransactionArgsForCall []struct {
		arg1 transaction.ID
	}
	getTransactionReturns struct {
		result1 *transaction.Transaction
		result2 error
	}
	getTransactionReturnsOnCall map[int]struct {
		result1 *transaction.Transaction
		result2 error
	}
	PutStateStub        func(*transaction.State) error
	putStateMutex       sync.RWMutex
	putStateArgsForCall []struct {
		arg1 *transaction.State
	}
	putStateReturns struct {
		result1 error
	}
	putStateReturnsOnCall map[int]struct {
		result1 error
	}
	PutTransactionStub        func(*transaction.Transaction) error
	putTransactionMutex       sync.RWMutex
	putTransactionArgsForCall []struct {
		arg1 *transaction.Transaction
	}
	putTransactionReturns struct {
		result1 error
	}
	putTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Repository) ConsumeStates(arg1 ...transaction.StateID) error {
	fake.consumeStatesMutex.Lock()
	ret, specificReturn := fake.consumeStatesReturnsOnCall[len(fake.consumeStatesArgsForCall)]
	fake.consumeStatesArgsForCall = append(fake.consumeStatesArgsForCall, struct {
		arg1 []transaction.StateID
	}{arg1})
	stub := fake.ConsumeStatesStub
	fakeReturns := fake.consumeStatesReturns
	fake.recordInvocation("ConsumeStates", []interface{}{arg1})
	fake.consumeStatesMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) ConsumeStatesCallCount() int {
	fake.consumeStatesMutex.RLock()
	defer fake.consumeStatesMutex.RUnlock()
	return len(fake.consumeStatesArgsForCall)
}

func (fake *Repository) ConsumeStatesCalls(stub func(...transaction.StateID) error) {
	fake.consumeStatesMutex.Lock()
	defer fake.consumeStatesMutex.Unlock()
	fake.ConsumeStatesStub = stub
}

func (fake *Repository) ConsumeStatesArgsForCall(i int) []transaction.StateID {
	fake.consumeStatesMutex.RLock()
	defer fake.consumeStatesMutex.RUnlock()
	argsForCall := fake.consumeStatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) ConsumeStatesReturns(result1 error) {
	fake.consumeStatesMutex.Lock()
	defer fake.consumeStatesMutex.Unlock()
	fake.ConsumeStatesStub = nil
	fake.consumeStatesReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) ConsumeStatesReturnsOnCall(i int, result1 error) {
	fake.consumeStatesMutex.Lock()
	defer fake.consumeStatesMutex.Unlock()
	fake.ConsumeStatesStub = nil
	if fake.consumeStatesReturnsOnCall == nil {
		fake.consumeStatesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consumeStatesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) GetState(arg1 transaction.StateID) (*transaction.State, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
		arg1 transaction.StateID
	}{arg1})
	stub := fake.GetStateStub
	fakeReturns := fake.getStateReturns
	fake.recordInvocation("GetState", []interface{}{arg1})
	fake.getStateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *Repository) GetStateCalls(stub func(transaction.StateID) (*transaction.State, error)) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = stub
}

func (fake *Repository) GetStateArgsForCall(i int) transaction.StateID {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	argsForCall := fake.getStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) GetStateReturns(result1 *transaction.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 *transaction.State
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetStateReturnsOnCall(i int, result1 *transaction.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 *transaction.State
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 *transaction.State
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransaction(arg1 transaction.ID) (*transaction.Transaction, error) {
	fake.getTransactionMutex.Lock()
	ret, specificReturn := fake.getTransactionReturnsOnCall[len(fake.getTransactionArgsForCall)]
	fake.getTransactionArgsForCall = append(fake.getTransactionArgsForCall, struct {
		arg1 transaction.ID
	}{arg1})
	stub := fake.GetTransactionStub
	fakeReturns := fake.getTransactionReturns
	fake.recordInvocation("GetTransaction", []interface{}{arg1})
	fake.getTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetTransactionCallCount() int {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	return len(fake.getTransactionArgsForCall)
}

func (fake *Repository) GetTransactionCalls(stub func(transaction.ID) (*transaction.Transaction, error)) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = stub
}

func (fake *Repository) GetTransactionArgsForCall(i int) transaction.ID {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	argsForCall := fake.getTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) GetTransactionReturns(result1 *transaction.Transaction, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	fake.getTransactionReturns = struct {
		result1 *transaction.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransactionReturnsOnCall(i int, result1 *transaction.Transaction, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	if fake.getTransactionReturnsOnCall == nil {
		fake.getTransactionReturnsOnCall = make(map[int]struct {
			result1 *transaction.Transaction
			result2 error
		})
	}
	fake.getTransactionReturnsOnCall[i] = struct {
		result1 *transaction.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) PutState(arg1 *transaction.State) error {
	fake.putStateMutex.Lock()
	ret, specificReturn := fake.putStateReturnsOnCall[len(fake.putStateArgsForCall)]
	fake.putStateArgsForCall = append(fake.putStateArgsForCall, struct {
		arg1 *transaction.State
	}{arg1})
	stub := fake.PutStateStub
	fakeReturns := fake.putStateReturns
	fake.recordInvocation("PutState", []interface{}{arg1})
	fake.putStateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) PutStateCallCount() int {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	return len(fake.putStateArgsForCall)
}

func (fake *Repository) PutStateCalls(stub func(*transaction.State) error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = stub
}

func (fake *Repository) PutStateArgsForCall(i int) *transaction.State {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	argsForCall := fake.putStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutStateReturns(result1 error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = nil
	fake.putStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutStateReturnsOnCall(i int, result1 error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = nil
	if fake.putStateReturnsOnCall == nil {
		fake.putStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutTransaction(arg1 *transaction.Transaction) error {
	fake.putTransactionMutex.Lock()
	ret, specificReturn := fake.putTransactionReturnsOnCall[len(fake.putTransactionArgsForCall)]
	fake.putTransactionArgsForCall = append(fake.putTransactionArgsForCall, struct {
		arg1 *transaction.Transaction
	}{arg1})
	stub := fake.PutTransactionStub
	fakeReturns := fake.putTransactionReturns
	fake.recordInvocation("PutTransaction", []interface{}{arg1})
	fake.putTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) PutTransactionCallCount() int {
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	return len(fake.putTransactionArgsForCall)
}

func (fake *Repository) PutTransactionCalls(stub func(*transaction.Transaction) error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = stub
}

func (fake *Repository) PutTransactionArgsForCall(i int) *transaction.Transaction {
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	argsForCall := fake.putTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutTransactionReturns(result1 error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = nil
	fake.putTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutTransactionReturnsOnCall(i int, result1 error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = nil
	if fake.putTransactionReturnsOnCall == nil {
		fake.putTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.consumeStatesMutex.RLock()
	defer fake.consumeStatesMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Repository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
