// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"github.com/sykesm/batik/pkg/transaction"
)

type Repository struct {
	ConsumeStateStub        func(transaction.StateID) error
	consumeStateMutex       sync.RWMutex
	consumeStateArgsForCall []struct {
		arg1 transaction.StateID
	}
	consumeStateReturns struct {
		result1 error
	}
	consumeStateReturnsOnCall map[int]struct {
		result1 error
	}
	GetCommittedStub        func(transaction.ID) (*transaction.Committed, error)
	getCommittedMutex       sync.RWMutex
	getCommittedArgsForCall []struct {
		arg1 transaction.ID
	}
	getCommittedReturns struct {
		result1 *transaction.Committed
		result2 error
	}
	getCommittedReturnsOnCall map[int]struct {
		result1 *transaction.Committed
		result2 error
	}
	GetReceiptStub        func([]byte) (*transaction.Receipt, error)
	getReceiptMutex       sync.RWMutex
	getReceiptArgsForCall []struct {
		arg1 []byte
	}
	getReceiptReturns struct {
		result1 *transaction.Receipt
		result2 error
	}
	getReceiptReturnsOnCall map[int]struct {
		result1 *transaction.Receipt
		result2 error
	}
	GetStateStub        func(transaction.StateID, bool) (*transaction.State, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
		arg1 transaction.StateID
		arg2 bool
	}
	getStateReturns struct {
		result1 *transaction.State
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 *transaction.State
		result2 error
	}
	GetTransactionStub        func(transaction.ID) (*transaction.Transaction, error)
	getTransactionMutex       sync.RWMutex
	getTransactionArgsForCall []struct {
		arg1 transaction.ID
	}
	getTransactionReturns struct {
		result1 *transaction.Transaction
		result2 error
	}
	getTransactionReturnsOnCall map[int]struct {
		result1 *transaction.Transaction
		result2 error
	}
	PutCommittedStub        func(transaction.ID, *transaction.Committed) error
	putCommittedMutex       sync.RWMutex
	putCommittedArgsForCall []struct {
		arg1 transaction.ID
		arg2 *transaction.Committed
	}
	putCommittedReturns struct {
		result1 error
	}
	putCommittedReturnsOnCall map[int]struct {
		result1 error
	}
	PutReceiptStub        func(*transaction.Receipt) error
	putReceiptMutex       sync.RWMutex
	putReceiptArgsForCall []struct {
		arg1 *transaction.Receipt
	}
	putReceiptReturns struct {
		result1 error
	}
	putReceiptReturnsOnCall map[int]struct {
		result1 error
	}
	PutStateStub        func(*transaction.State) error
	putStateMutex       sync.RWMutex
	putStateArgsForCall []struct {
		arg1 *transaction.State
	}
	putStateReturns struct {
		result1 error
	}
	putStateReturnsOnCall map[int]struct {
		result1 error
	}
	PutTransactionStub        func(*transaction.Transaction) error
	putTransactionMutex       sync.RWMutex
	putTransactionArgsForCall []struct {
		arg1 *transaction.Transaction
	}
	putTransactionReturns struct {
		result1 error
	}
	putTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Repository) ConsumeState(arg1 transaction.StateID) error {
	fake.consumeStateMutex.Lock()
	ret, specificReturn := fake.consumeStateReturnsOnCall[len(fake.consumeStateArgsForCall)]
	fake.consumeStateArgsForCall = append(fake.consumeStateArgsForCall, struct {
		arg1 transaction.StateID
	}{arg1})
	fake.recordInvocation("ConsumeState", []interface{}{arg1})
	fake.consumeStateMutex.Unlock()
	if fake.ConsumeStateStub != nil {
		return fake.ConsumeStateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.consumeStateReturns
	return fakeReturns.result1
}

func (fake *Repository) ConsumeStateCallCount() int {
	fake.consumeStateMutex.RLock()
	defer fake.consumeStateMutex.RUnlock()
	return len(fake.consumeStateArgsForCall)
}

func (fake *Repository) ConsumeStateCalls(stub func(transaction.StateID) error) {
	fake.consumeStateMutex.Lock()
	defer fake.consumeStateMutex.Unlock()
	fake.ConsumeStateStub = stub
}

func (fake *Repository) ConsumeStateArgsForCall(i int) transaction.StateID {
	fake.consumeStateMutex.RLock()
	defer fake.consumeStateMutex.RUnlock()
	argsForCall := fake.consumeStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) ConsumeStateReturns(result1 error) {
	fake.consumeStateMutex.Lock()
	defer fake.consumeStateMutex.Unlock()
	fake.ConsumeStateStub = nil
	fake.consumeStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) ConsumeStateReturnsOnCall(i int, result1 error) {
	fake.consumeStateMutex.Lock()
	defer fake.consumeStateMutex.Unlock()
	fake.ConsumeStateStub = nil
	if fake.consumeStateReturnsOnCall == nil {
		fake.consumeStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consumeStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) GetCommitted(arg1 transaction.ID) (*transaction.Committed, error) {
	fake.getCommittedMutex.Lock()
	ret, specificReturn := fake.getCommittedReturnsOnCall[len(fake.getCommittedArgsForCall)]
	fake.getCommittedArgsForCall = append(fake.getCommittedArgsForCall, struct {
		arg1 transaction.ID
	}{arg1})
	fake.recordInvocation("GetCommitted", []interface{}{arg1})
	fake.getCommittedMutex.Unlock()
	if fake.GetCommittedStub != nil {
		return fake.GetCommittedStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCommittedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetCommittedCallCount() int {
	fake.getCommittedMutex.RLock()
	defer fake.getCommittedMutex.RUnlock()
	return len(fake.getCommittedArgsForCall)
}

func (fake *Repository) GetCommittedCalls(stub func(transaction.ID) (*transaction.Committed, error)) {
	fake.getCommittedMutex.Lock()
	defer fake.getCommittedMutex.Unlock()
	fake.GetCommittedStub = stub
}

func (fake *Repository) GetCommittedArgsForCall(i int) transaction.ID {
	fake.getCommittedMutex.RLock()
	defer fake.getCommittedMutex.RUnlock()
	argsForCall := fake.getCommittedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) GetCommittedReturns(result1 *transaction.Committed, result2 error) {
	fake.getCommittedMutex.Lock()
	defer fake.getCommittedMutex.Unlock()
	fake.GetCommittedStub = nil
	fake.getCommittedReturns = struct {
		result1 *transaction.Committed
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetCommittedReturnsOnCall(i int, result1 *transaction.Committed, result2 error) {
	fake.getCommittedMutex.Lock()
	defer fake.getCommittedMutex.Unlock()
	fake.GetCommittedStub = nil
	if fake.getCommittedReturnsOnCall == nil {
		fake.getCommittedReturnsOnCall = make(map[int]struct {
			result1 *transaction.Committed
			result2 error
		})
	}
	fake.getCommittedReturnsOnCall[i] = struct {
		result1 *transaction.Committed
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetReceipt(arg1 []byte) (*transaction.Receipt, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getReceiptMutex.Lock()
	ret, specificReturn := fake.getReceiptReturnsOnCall[len(fake.getReceiptArgsForCall)]
	fake.getReceiptArgsForCall = append(fake.getReceiptArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("GetReceipt", []interface{}{arg1Copy})
	fake.getReceiptMutex.Unlock()
	if fake.GetReceiptStub != nil {
		return fake.GetReceiptStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReceiptReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetReceiptCallCount() int {
	fake.getReceiptMutex.RLock()
	defer fake.getReceiptMutex.RUnlock()
	return len(fake.getReceiptArgsForCall)
}

func (fake *Repository) GetReceiptCalls(stub func([]byte) (*transaction.Receipt, error)) {
	fake.getReceiptMutex.Lock()
	defer fake.getReceiptMutex.Unlock()
	fake.GetReceiptStub = stub
}

func (fake *Repository) GetReceiptArgsForCall(i int) []byte {
	fake.getReceiptMutex.RLock()
	defer fake.getReceiptMutex.RUnlock()
	argsForCall := fake.getReceiptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) GetReceiptReturns(result1 *transaction.Receipt, result2 error) {
	fake.getReceiptMutex.Lock()
	defer fake.getReceiptMutex.Unlock()
	fake.GetReceiptStub = nil
	fake.getReceiptReturns = struct {
		result1 *transaction.Receipt
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetReceiptReturnsOnCall(i int, result1 *transaction.Receipt, result2 error) {
	fake.getReceiptMutex.Lock()
	defer fake.getReceiptMutex.Unlock()
	fake.GetReceiptStub = nil
	if fake.getReceiptReturnsOnCall == nil {
		fake.getReceiptReturnsOnCall = make(map[int]struct {
			result1 *transaction.Receipt
			result2 error
		})
	}
	fake.getReceiptReturnsOnCall[i] = struct {
		result1 *transaction.Receipt
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetState(arg1 transaction.StateID, arg2 bool) (*transaction.State, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
		arg1 transaction.StateID
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("GetState", []interface{}{arg1, arg2})
	fake.getStateMutex.Unlock()
	if fake.GetStateStub != nil {
		return fake.GetStateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getStateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *Repository) GetStateCalls(stub func(transaction.StateID, bool) (*transaction.State, error)) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = stub
}

func (fake *Repository) GetStateArgsForCall(i int) (transaction.StateID, bool) {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	argsForCall := fake.getStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Repository) GetStateReturns(result1 *transaction.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 *transaction.State
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetStateReturnsOnCall(i int, result1 *transaction.State, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 *transaction.State
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 *transaction.State
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransaction(arg1 transaction.ID) (*transaction.Transaction, error) {
	fake.getTransactionMutex.Lock()
	ret, specificReturn := fake.getTransactionReturnsOnCall[len(fake.getTransactionArgsForCall)]
	fake.getTransactionArgsForCall = append(fake.getTransactionArgsForCall, struct {
		arg1 transaction.ID
	}{arg1})
	fake.recordInvocation("GetTransaction", []interface{}{arg1})
	fake.getTransactionMutex.Unlock()
	if fake.GetTransactionStub != nil {
		return fake.GetTransactionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetTransactionCallCount() int {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	return len(fake.getTransactionArgsForCall)
}

func (fake *Repository) GetTransactionCalls(stub func(transaction.ID) (*transaction.Transaction, error)) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = stub
}

func (fake *Repository) GetTransactionArgsForCall(i int) transaction.ID {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	argsForCall := fake.getTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) GetTransactionReturns(result1 *transaction.Transaction, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	fake.getTransactionReturns = struct {
		result1 *transaction.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransactionReturnsOnCall(i int, result1 *transaction.Transaction, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	if fake.getTransactionReturnsOnCall == nil {
		fake.getTransactionReturnsOnCall = make(map[int]struct {
			result1 *transaction.Transaction
			result2 error
		})
	}
	fake.getTransactionReturnsOnCall[i] = struct {
		result1 *transaction.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) PutCommitted(arg1 transaction.ID, arg2 *transaction.Committed) error {
	fake.putCommittedMutex.Lock()
	ret, specificReturn := fake.putCommittedReturnsOnCall[len(fake.putCommittedArgsForCall)]
	fake.putCommittedArgsForCall = append(fake.putCommittedArgsForCall, struct {
		arg1 transaction.ID
		arg2 *transaction.Committed
	}{arg1, arg2})
	fake.recordInvocation("PutCommitted", []interface{}{arg1, arg2})
	fake.putCommittedMutex.Unlock()
	if fake.PutCommittedStub != nil {
		return fake.PutCommittedStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.putCommittedReturns
	return fakeReturns.result1
}

func (fake *Repository) PutCommittedCallCount() int {
	fake.putCommittedMutex.RLock()
	defer fake.putCommittedMutex.RUnlock()
	return len(fake.putCommittedArgsForCall)
}

func (fake *Repository) PutCommittedCalls(stub func(transaction.ID, *transaction.Committed) error) {
	fake.putCommittedMutex.Lock()
	defer fake.putCommittedMutex.Unlock()
	fake.PutCommittedStub = stub
}

func (fake *Repository) PutCommittedArgsForCall(i int) (transaction.ID, *transaction.Committed) {
	fake.putCommittedMutex.RLock()
	defer fake.putCommittedMutex.RUnlock()
	argsForCall := fake.putCommittedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Repository) PutCommittedReturns(result1 error) {
	fake.putCommittedMutex.Lock()
	defer fake.putCommittedMutex.Unlock()
	fake.PutCommittedStub = nil
	fake.putCommittedReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutCommittedReturnsOnCall(i int, result1 error) {
	fake.putCommittedMutex.Lock()
	defer fake.putCommittedMutex.Unlock()
	fake.PutCommittedStub = nil
	if fake.putCommittedReturnsOnCall == nil {
		fake.putCommittedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putCommittedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutReceipt(arg1 *transaction.Receipt) error {
	fake.putReceiptMutex.Lock()
	ret, specificReturn := fake.putReceiptReturnsOnCall[len(fake.putReceiptArgsForCall)]
	fake.putReceiptArgsForCall = append(fake.putReceiptArgsForCall, struct {
		arg1 *transaction.Receipt
	}{arg1})
	fake.recordInvocation("PutReceipt", []interface{}{arg1})
	fake.putReceiptMutex.Unlock()
	if fake.PutReceiptStub != nil {
		return fake.PutReceiptStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.putReceiptReturns
	return fakeReturns.result1
}

func (fake *Repository) PutReceiptCallCount() int {
	fake.putReceiptMutex.RLock()
	defer fake.putReceiptMutex.RUnlock()
	return len(fake.putReceiptArgsForCall)
}

func (fake *Repository) PutReceiptCalls(stub func(*transaction.Receipt) error) {
	fake.putReceiptMutex.Lock()
	defer fake.putReceiptMutex.Unlock()
	fake.PutReceiptStub = stub
}

func (fake *Repository) PutReceiptArgsForCall(i int) *transaction.Receipt {
	fake.putReceiptMutex.RLock()
	defer fake.putReceiptMutex.RUnlock()
	argsForCall := fake.putReceiptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutReceiptReturns(result1 error) {
	fake.putReceiptMutex.Lock()
	defer fake.putReceiptMutex.Unlock()
	fake.PutReceiptStub = nil
	fake.putReceiptReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutReceiptReturnsOnCall(i int, result1 error) {
	fake.putReceiptMutex.Lock()
	defer fake.putReceiptMutex.Unlock()
	fake.PutReceiptStub = nil
	if fake.putReceiptReturnsOnCall == nil {
		fake.putReceiptReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putReceiptReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutState(arg1 *transaction.State) error {
	fake.putStateMutex.Lock()
	ret, specificReturn := fake.putStateReturnsOnCall[len(fake.putStateArgsForCall)]
	fake.putStateArgsForCall = append(fake.putStateArgsForCall, struct {
		arg1 *transaction.State
	}{arg1})
	fake.recordInvocation("PutState", []interface{}{arg1})
	fake.putStateMutex.Unlock()
	if fake.PutStateStub != nil {
		return fake.PutStateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.putStateReturns
	return fakeReturns.result1
}

func (fake *Repository) PutStateCallCount() int {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	return len(fake.putStateArgsForCall)
}

func (fake *Repository) PutStateCalls(stub func(*transaction.State) error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = stub
}

func (fake *Repository) PutStateArgsForCall(i int) *transaction.State {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	argsForCall := fake.putStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutStateReturns(result1 error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = nil
	fake.putStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutStateReturnsOnCall(i int, result1 error) {
	fake.putStateMutex.Lock()
	defer fake.putStateMutex.Unlock()
	fake.PutStateStub = nil
	if fake.putStateReturnsOnCall == nil {
		fake.putStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutTransaction(arg1 *transaction.Transaction) error {
	fake.putTransactionMutex.Lock()
	ret, specificReturn := fake.putTransactionReturnsOnCall[len(fake.putTransactionArgsForCall)]
	fake.putTransactionArgsForCall = append(fake.putTransactionArgsForCall, struct {
		arg1 *transaction.Transaction
	}{arg1})
	fake.recordInvocation("PutTransaction", []interface{}{arg1})
	fake.putTransactionMutex.Unlock()
	if fake.PutTransactionStub != nil {
		return fake.PutTransactionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.putTransactionReturns
	return fakeReturns.result1
}

func (fake *Repository) PutTransactionCallCount() int {
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	return len(fake.putTransactionArgsForCall)
}

func (fake *Repository) PutTransactionCalls(stub func(*transaction.Transaction) error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = stub
}

func (fake *Repository) PutTransactionArgsForCall(i int) *transaction.Transaction {
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	argsForCall := fake.putTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Repository) PutTransactionReturns(result1 error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = nil
	fake.putTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) PutTransactionReturnsOnCall(i int, result1 error) {
	fake.putTransactionMutex.Lock()
	defer fake.putTransactionMutex.Unlock()
	fake.PutTransactionStub = nil
	if fake.putTransactionReturnsOnCall == nil {
		fake.putTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.consumeStateMutex.RLock()
	defer fake.consumeStateMutex.RUnlock()
	fake.getCommittedMutex.RLock()
	defer fake.getCommittedMutex.RUnlock()
	fake.getReceiptMutex.RLock()
	defer fake.getReceiptMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	fake.putCommittedMutex.RLock()
	defer fake.putCommittedMutex.RUnlock()
	fake.putReceiptMutex.RLock()
	defer fake.putReceiptMutex.RUnlock()
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	fake.putTransactionMutex.RLock()
	defer fake.putTransactionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Repository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
